<!DOCTYPE HTML>
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../stylesheet.css" title="Style">
</head>
<body>
<main role="main">
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span><a id="line.1">/*</a>
<span class="sourceLineNo">002</span><a id="line.2"> *                    BioJava development code</a>
<span class="sourceLineNo">003</span><a id="line.3"> *</a>
<span class="sourceLineNo">004</span><a id="line.4"> * This code may be freely distributed and modified under the</a>
<span class="sourceLineNo">005</span><a id="line.5"> * terms of the GNU Lesser General Public Licence.  This should</a>
<span class="sourceLineNo">006</span><a id="line.6"> * be distributed with the code.  If you do not have a copy,</a>
<span class="sourceLineNo">007</span><a id="line.7"> * see:</a>
<span class="sourceLineNo">008</span><a id="line.8"> *</a>
<span class="sourceLineNo">009</span><a id="line.9"> *      http://www.gnu.org/copyleft/lesser.html</a>
<span class="sourceLineNo">010</span><a id="line.10"> *</a>
<span class="sourceLineNo">011</span><a id="line.11"> * Copyright for this code is held jointly by the individual</a>
<span class="sourceLineNo">012</span><a id="line.12"> * authors.  These should be listed in @author doc comments.</a>
<span class="sourceLineNo">013</span><a id="line.13"> *</a>
<span class="sourceLineNo">014</span><a id="line.14"> * For more information on the BioJava project and its aims,</a>
<span class="sourceLineNo">015</span><a id="line.15"> * or to join the biojava-l mailing list, visit the home page</a>
<span class="sourceLineNo">016</span><a id="line.16"> * at:</a>
<span class="sourceLineNo">017</span><a id="line.17"> *</a>
<span class="sourceLineNo">018</span><a id="line.18"> *      http://www.biojava.org/</a>
<span class="sourceLineNo">019</span><a id="line.19"> *</a>
<span class="sourceLineNo">020</span><a id="line.20"> */</a>
<span class="sourceLineNo">021</span><a id="line.21"></a>
<span class="sourceLineNo">022</span><a id="line.22">package org.biojavax.bio.seq;</a>
<span class="sourceLineNo">023</span><a id="line.23"></a>
<span class="sourceLineNo">024</span><a id="line.24">import java.util.ArrayList;</a>
<span class="sourceLineNo">025</span><a id="line.25">import java.util.Collection;</a>
<span class="sourceLineNo">026</span><a id="line.26">import java.util.Iterator;</a>
<span class="sourceLineNo">027</span><a id="line.27">import java.util.List;</a>
<span class="sourceLineNo">028</span><a id="line.28"></a>
<span class="sourceLineNo">029</span><a id="line.29">import org.biojava.bio.symbol.FuzzyLocation;</a>
<span class="sourceLineNo">030</span><a id="line.30">import org.biojava.bio.symbol.FuzzyPointLocation;</a>
<span class="sourceLineNo">031</span><a id="line.31">import org.biojava.bio.symbol.Location;</a>
<span class="sourceLineNo">032</span><a id="line.32">import org.biojava.bio.symbol.MergeLocation;</a>
<span class="sourceLineNo">033</span><a id="line.33">import org.biojava.bio.symbol.PointLocation;</a>
<span class="sourceLineNo">034</span><a id="line.34">import org.biojava.bio.symbol.RangeLocation;</a>
<span class="sourceLineNo">035</span><a id="line.35">import org.biojava.utils.ChangeType;</a>
<span class="sourceLineNo">036</span><a id="line.36">import org.biojava.utils.ChangeVetoException;</a>
<span class="sourceLineNo">037</span><a id="line.37">import org.biojavax.CrossRef;</a>
<span class="sourceLineNo">038</span><a id="line.38">import org.biojavax.CrossReferenceResolver;</a>
<span class="sourceLineNo">039</span><a id="line.39">import org.biojavax.RichAnnotatable;</a>
<span class="sourceLineNo">040</span><a id="line.40">import org.biojavax.ontology.ComparableTerm;</a>
<span class="sourceLineNo">041</span><a id="line.41"></a>
<span class="sourceLineNo">042</span><a id="line.42">/**</a>
<span class="sourceLineNo">043</span><a id="line.43"> * Describes locations, and adds the concepts of circularity, fuzziness,</a>
<span class="sourceLineNo">044</span><a id="line.44"> * annotations, and cross-references to other databases. Also includes strands.</a>
<span class="sourceLineNo">045</span><a id="line.45"> * </a>
<span class="sourceLineNo">046</span><a id="line.46"> * @author Richard Holland</a>
<span class="sourceLineNo">047</span><a id="line.47"> * @author George Waldon - bug fix</a>
<span class="sourceLineNo">048</span><a id="line.48"> * @since 1.5</a>
<span class="sourceLineNo">049</span><a id="line.49"> */</a>
<span class="sourceLineNo">050</span><a id="line.50">public interface RichLocation extends Location, RichAnnotatable, Comparable {</a>
<span class="sourceLineNo">051</span><a id="line.51"></a>
<span class="sourceLineNo">052</span><a id="line.52">        public static final ChangeType NOTE = new ChangeType(</a>
<span class="sourceLineNo">053</span><a id="line.53">                        "This location's notes have changed",</a>
<span class="sourceLineNo">054</span><a id="line.54">                        "org.biojavax.bio.seq.RichLocation", "NOTE");</a>
<span class="sourceLineNo">055</span><a id="line.55">        public static final ChangeType TERM = new ChangeType(</a>
<span class="sourceLineNo">056</span><a id="line.56">                        "This location's term has changed",</a>
<span class="sourceLineNo">057</span><a id="line.57">                        "org.biojavax.bio.seq.RichLocation", "TERM");</a>
<span class="sourceLineNo">058</span><a id="line.58">        public static final ChangeType RANK = new ChangeType(</a>
<span class="sourceLineNo">059</span><a id="line.59">                        "This location's rank has changed",</a>
<span class="sourceLineNo">060</span><a id="line.60">                        "org.biojavax.bio.seq.RichLocation", "RANK");</a>
<span class="sourceLineNo">061</span><a id="line.61">        public static final ChangeType CIRCULAR = new ChangeType(</a>
<span class="sourceLineNo">062</span><a id="line.62">                        "This location's circularity has changed",</a>
<span class="sourceLineNo">063</span><a id="line.63">                        "org.biojavax.bio.seq.RichLocation", "CIRCULAR");</a>
<span class="sourceLineNo">064</span><a id="line.64">        public static final ChangeType FEATURE = new ChangeType(</a>
<span class="sourceLineNo">065</span><a id="line.65">                        "This location's parent feature has changed",</a>
<span class="sourceLineNo">066</span><a id="line.66">                        "org.biojavax.bio.seq.RichLocation", "FEATURE");</a>
<span class="sourceLineNo">067</span><a id="line.67"></a>
<span class="sourceLineNo">068</span><a id="line.68">        /**</a>
<span class="sourceLineNo">069</span><a id="line.69">         * The empty location matches nothing.</a>
<span class="sourceLineNo">070</span><a id="line.70">         */</a>
<span class="sourceLineNo">071</span><a id="line.71">        public static final RichLocation EMPTY_LOCATION = new EmptyRichLocation();</a>
<span class="sourceLineNo">072</span><a id="line.72"></a>
<span class="sourceLineNo">073</span><a id="line.73">        /**</a>
<span class="sourceLineNo">074</span><a id="line.74">         * Sorts the member locations of a compound location. Does nothing for</a>
<span class="sourceLineNo">075</span><a id="line.75">         * non-compound locations. Sorting depends on the compareTo() method of the</a>
<span class="sourceLineNo">076</span><a id="line.76">         * member locations - usually they will be sorted by their start position.</a>
<span class="sourceLineNo">077</span><a id="line.77">         * This might be useful when used with the location returned by a union or</a>
<span class="sourceLineNo">078</span><a id="line.78">         * intersection, or when setting the term of a compound location to</a>
<span class="sourceLineNo">079</span><a id="line.79">         * ORDER_TERM.</a>
<span class="sourceLineNo">080</span><a id="line.80">         */</a>
<span class="sourceLineNo">081</span><a id="line.81">        public void sort();</a>
<span class="sourceLineNo">082</span><a id="line.82"></a>
<span class="sourceLineNo">083</span><a id="line.83">        /**</a>
<span class="sourceLineNo">084</span><a id="line.84">         * Retrieves the feature this location is associated with. May be null.</a>
<span class="sourceLineNo">085</span><a id="line.85">         * </a>
<span class="sourceLineNo">086</span><a id="line.86">         * @return the feature.</a>
<span class="sourceLineNo">087</span><a id="line.87">         */</a>
<span class="sourceLineNo">088</span><a id="line.88">        public RichFeature getFeature();</a>
<span class="sourceLineNo">089</span><a id="line.89"></a>
<span class="sourceLineNo">090</span><a id="line.90">        /**</a>
<span class="sourceLineNo">091</span><a id="line.91">         * Sets the feature this location is associated with. If null, that's fine,</a>
<span class="sourceLineNo">092</span><a id="line.92">         * but you won't be able to persist it to the database until you give it a</a>
<span class="sourceLineNo">093</span><a id="line.93">         * not-null value.</a>
<span class="sourceLineNo">094</span><a id="line.94">         * </a>
<span class="sourceLineNo">095</span><a id="line.95">         * @param feature</a>
<span class="sourceLineNo">096</span><a id="line.96">         *            the feature.</a>
<span class="sourceLineNo">097</span><a id="line.97">         */</a>
<span class="sourceLineNo">098</span><a id="line.98">        public void setFeature(RichFeature feature) throws ChangeVetoException;</a>
<span class="sourceLineNo">099</span><a id="line.99"></a>
<span class="sourceLineNo">100</span><a id="line.100">        /**</a>
<span class="sourceLineNo">101</span><a id="line.101">         * Retrieves the crossref associated with this location.</a>
<span class="sourceLineNo">102</span><a id="line.102">         * </a>
<span class="sourceLineNo">103</span><a id="line.103">         * @return the crossref.</a>
<span class="sourceLineNo">104</span><a id="line.104">         */</a>
<span class="sourceLineNo">105</span><a id="line.105">        public CrossRef getCrossRef();</a>
<span class="sourceLineNo">106</span><a id="line.106"></a>
<span class="sourceLineNo">107</span><a id="line.107">        /**</a>
<span class="sourceLineNo">108</span><a id="line.108">         * Retrieves the term associated with this location.</a>
<span class="sourceLineNo">109</span><a id="line.109">         * </a>
<span class="sourceLineNo">110</span><a id="line.110">         * @return the term.</a>
<span class="sourceLineNo">111</span><a id="line.111">         */</a>
<span class="sourceLineNo">112</span><a id="line.112">        public ComparableTerm getTerm();</a>
<span class="sourceLineNo">113</span><a id="line.113"></a>
<span class="sourceLineNo">114</span><a id="line.114">        /**</a>
<span class="sourceLineNo">115</span><a id="line.115">         * Sets the term for this location.</a>
<span class="sourceLineNo">116</span><a id="line.116">         * </a>
<span class="sourceLineNo">117</span><a id="line.117">         * @param term</a>
<span class="sourceLineNo">118</span><a id="line.118">         *            the term this location should adopt.</a>
<span class="sourceLineNo">119</span><a id="line.119">         * @throws ChangeVetoException</a>
<span class="sourceLineNo">120</span><a id="line.120">         *             in case of error.</a>
<span class="sourceLineNo">121</span><a id="line.121">         */</a>
<span class="sourceLineNo">122</span><a id="line.122">        public void setTerm(ComparableTerm term) throws ChangeVetoException;</a>
<span class="sourceLineNo">123</span><a id="line.123"></a>
<span class="sourceLineNo">124</span><a id="line.124">        /**</a>
<span class="sourceLineNo">125</span><a id="line.125">         * Retrieves the strand associated with this location.</a>
<span class="sourceLineNo">126</span><a id="line.126">         * </a>
<span class="sourceLineNo">127</span><a id="line.127">         * @return the strand.</a>
<span class="sourceLineNo">128</span><a id="line.128">         */</a>
<span class="sourceLineNo">129</span><a id="line.129">        public Strand getStrand();</a>
<span class="sourceLineNo">130</span><a id="line.130"></a>
<span class="sourceLineNo">131</span><a id="line.131">        /**</a>
<span class="sourceLineNo">132</span><a id="line.132">         * Retrieves the rank associated with this location.</a>
<span class="sourceLineNo">133</span><a id="line.133">         * </a>
<span class="sourceLineNo">134</span><a id="line.134">         * @return the rank.</a>
<span class="sourceLineNo">135</span><a id="line.135">         */</a>
<span class="sourceLineNo">136</span><a id="line.136">        public int getRank();</a>
<span class="sourceLineNo">137</span><a id="line.137"></a>
<span class="sourceLineNo">138</span><a id="line.138">        /**</a>
<span class="sourceLineNo">139</span><a id="line.139">         * Sets the rank for this location.</a>
<span class="sourceLineNo">140</span><a id="line.140">         * </a>
<span class="sourceLineNo">141</span><a id="line.141">         * @param rank</a>
<span class="sourceLineNo">142</span><a id="line.142">         *            the rank this location should adopt.</a>
<span class="sourceLineNo">143</span><a id="line.143">         * @throws ChangeVetoException</a>
<span class="sourceLineNo">144</span><a id="line.144">         *             in case of error.</a>
<span class="sourceLineNo">145</span><a id="line.145">         */</a>
<span class="sourceLineNo">146</span><a id="line.146">        public void setRank(int rank) throws ChangeVetoException;</a>
<span class="sourceLineNo">147</span><a id="line.147"></a>
<span class="sourceLineNo">148</span><a id="line.148">        /**</a>
<span class="sourceLineNo">149</span><a id="line.149">         * Retrieves the start position of this location.</a>
<span class="sourceLineNo">150</span><a id="line.150">         * </a>
<span class="sourceLineNo">151</span><a id="line.151">         * @return the position.</a>
<span class="sourceLineNo">152</span><a id="line.152">         */</a>
<span class="sourceLineNo">153</span><a id="line.153">        public Position getMinPosition();</a>
<span class="sourceLineNo">154</span><a id="line.154"></a>
<span class="sourceLineNo">155</span><a id="line.155">        /**</a>
<span class="sourceLineNo">156</span><a id="line.156">         * Retrieves the end position of this location.</a>
<span class="sourceLineNo">157</span><a id="line.157">         * </a>
<span class="sourceLineNo">158</span><a id="line.158">         * @return the position.</a>
<span class="sourceLineNo">159</span><a id="line.159">         */</a>
<span class="sourceLineNo">160</span><a id="line.160">        public Position getMaxPosition();</a>
<span class="sourceLineNo">161</span><a id="line.161"></a>
<span class="sourceLineNo">162</span><a id="line.162">        /**</a>
<span class="sourceLineNo">163</span><a id="line.163">         * Sets the resolver to use when working out actual base coordinates from</a>
<span class="sourceLineNo">164</span><a id="line.164">         * fuzzy positions.</a>
<span class="sourceLineNo">165</span><a id="line.165">         * </a>
<span class="sourceLineNo">166</span><a id="line.166">         * @param p</a>
<span class="sourceLineNo">167</span><a id="line.167">         *            the position resolver to use.</a>
<span class="sourceLineNo">168</span><a id="line.168">         */</a>
<span class="sourceLineNo">169</span><a id="line.169">        public void setPositionResolver(PositionResolver p);</a>
<span class="sourceLineNo">170</span><a id="line.170"></a>
<span class="sourceLineNo">171</span><a id="line.171">        /**</a>
<span class="sourceLineNo">172</span><a id="line.172">         * Retrieves the circular length of this location. If it is 0, the location</a>
<span class="sourceLineNo">173</span><a id="line.173">         * is not circular. If it is not zero, then the number refers to the</a>
<span class="sourceLineNo">174</span><a id="line.174">         * wrapping length of the location. eg. 100 would signify that a position of</a>
<span class="sourceLineNo">175</span><a id="line.175">         * 112 would actually be a position of 112-100 = 12.</a>
<span class="sourceLineNo">176</span><a id="line.176">         * </a>
<span class="sourceLineNo">177</span><a id="line.177">         * @return the position.</a>
<span class="sourceLineNo">178</span><a id="line.178">         */</a>
<span class="sourceLineNo">179</span><a id="line.179">        public int getCircularLength();</a>
<span class="sourceLineNo">180</span><a id="line.180"></a>
<span class="sourceLineNo">181</span><a id="line.181">        /**</a>
<span class="sourceLineNo">182</span><a id="line.182">         * Sets the circular length of this location. If it is 0, the location is</a>
<span class="sourceLineNo">183</span><a id="line.183">         * not circular. If it is not zero, then the number refers to the wrapping</a>
<span class="sourceLineNo">184</span><a id="line.184">         * length of the location. eg. 100 would signify that a position of 112</a>
<span class="sourceLineNo">185</span><a id="line.185">         * would actually be a position of 112-100 = 12.</a>
<span class="sourceLineNo">186</span><a id="line.186">         * </a>
<span class="sourceLineNo">187</span><a id="line.187">         * @param sourceSeqLength</a>
<span class="sourceLineNo">188</span><a id="line.188">         *            the circular length of this location</a>
<span class="sourceLineNo">189</span><a id="line.189">         * @throws ChangeVetoException</a>
<span class="sourceLineNo">190</span><a id="line.190">         *             if it doesn't want to change.</a>
<span class="sourceLineNo">191</span><a id="line.191">         */</a>
<span class="sourceLineNo">192</span><a id="line.192">        public void setCircularLength(int sourceSeqLength)</a>
<span class="sourceLineNo">193</span><a id="line.193">                        throws ChangeVetoException;</a>
<span class="sourceLineNo">194</span><a id="line.194"></a>
<span class="sourceLineNo">195</span><a id="line.195">        /**</a>
<span class="sourceLineNo">196</span><a id="line.196">         * Sets the cross ref resolver to use when retrieving remote symbols. If</a>
<span class="sourceLineNo">197</span><a id="line.197">         * none is given, then the default from</a>
<span class="sourceLineNo">198</span><a id="line.198">         * RichObjectFactory.getDefaultCrossRefResolver() is used.</a>
<span class="sourceLineNo">199</span><a id="line.199">         * </a>
<span class="sourceLineNo">200</span><a id="line.200">         * @param r</a>
<span class="sourceLineNo">201</span><a id="line.201">         *            the resolver to use.</a>
<span class="sourceLineNo">202</span><a id="line.202">         */</a>
<span class="sourceLineNo">203</span><a id="line.203">        public void setCrossRefResolver(CrossReferenceResolver r);</a>
<span class="sourceLineNo">204</span><a id="line.204"></a>
<span class="sourceLineNo">205</span><a id="line.205">        /**</a>
<span class="sourceLineNo">206</span><a id="line.206">         * This class represents a strand on which a location may lie. Three strands</a>
<span class="sourceLineNo">207</span><a id="line.207">         * are defined by default - UNKNOWN, NEGATIVE, and POSITIVE.</a>
<span class="sourceLineNo">208</span><a id="line.208">         */</a>
<span class="sourceLineNo">209</span><a id="line.209">        public static class Strand implements Comparable {</a>
<span class="sourceLineNo">210</span><a id="line.210"></a>
<span class="sourceLineNo">211</span><a id="line.211">                private String name;</a>
<span class="sourceLineNo">212</span><a id="line.212">                private int value;</a>
<span class="sourceLineNo">213</span><a id="line.213"></a>
<span class="sourceLineNo">214</span><a id="line.214">                /**</a>
<span class="sourceLineNo">215</span><a id="line.215">                 * The positive strand is represented by the symbol '+' and has the</a>
<span class="sourceLineNo">216</span><a id="line.216">                 * number 1.</a>
<span class="sourceLineNo">217</span><a id="line.217">                 */</a>
<span class="sourceLineNo">218</span><a id="line.218">                public static final Strand POSITIVE_STRAND = new Strand("+", 1);</a>
<span class="sourceLineNo">219</span><a id="line.219"></a>
<span class="sourceLineNo">220</span><a id="line.220">                /**</a>
<span class="sourceLineNo">221</span><a id="line.221">                 * The negative strand is represented by the symbol '-' and has the</a>
<span class="sourceLineNo">222</span><a id="line.222">                 * number -1.</a>
<span class="sourceLineNo">223</span><a id="line.223">                 */</a>
<span class="sourceLineNo">224</span><a id="line.224">                public static final Strand NEGATIVE_STRAND = new Strand("-", -1);</a>
<span class="sourceLineNo">225</span><a id="line.225"></a>
<span class="sourceLineNo">226</span><a id="line.226">                /**</a>
<span class="sourceLineNo">227</span><a id="line.227">                 * The unknown strand is represented by the symbol '?' and has the</a>
<span class="sourceLineNo">228</span><a id="line.228">                 * number 0.</a>
<span class="sourceLineNo">229</span><a id="line.229">                 */</a>
<span class="sourceLineNo">230</span><a id="line.230">                public static final Strand UNKNOWN_STRAND = new Strand("?", 0);</a>
<span class="sourceLineNo">231</span><a id="line.231"></a>
<span class="sourceLineNo">232</span><a id="line.232">                /**</a>
<span class="sourceLineNo">233</span><a id="line.233">                 * Returns the strand object that matches the number given. Throws an</a>
<span class="sourceLineNo">234</span><a id="line.234">                 * exception if it could not recognise the number. Number is usually</a>
<span class="sourceLineNo">235</span><a id="line.235">                 * 1,-1,0.</a>
<span class="sourceLineNo">236</span><a id="line.236">                 * </a>
<span class="sourceLineNo">237</span><a id="line.237">                 * @param value</a>
<span class="sourceLineNo">238</span><a id="line.238">                 *            the number of the strand.</a>
<span class="sourceLineNo">239</span><a id="line.239">                 * @return the strand matching that number.</a>
<span class="sourceLineNo">240</span><a id="line.240">                 */</a>
<span class="sourceLineNo">241</span><a id="line.241">                public static Strand forValue(int value) {</a>
<span class="sourceLineNo">242</span><a id="line.242">                        switch (value) {</a>
<span class="sourceLineNo">243</span><a id="line.243">                        case 1:</a>
<span class="sourceLineNo">244</span><a id="line.244">                                return POSITIVE_STRAND;</a>
<span class="sourceLineNo">245</span><a id="line.245">                        case 0:</a>
<span class="sourceLineNo">246</span><a id="line.246">                                return UNKNOWN_STRAND;</a>
<span class="sourceLineNo">247</span><a id="line.247">                        case -1:</a>
<span class="sourceLineNo">248</span><a id="line.248">                                return NEGATIVE_STRAND;</a>
<span class="sourceLineNo">249</span><a id="line.249">                        default:</a>
<span class="sourceLineNo">250</span><a id="line.250">                                throw new IllegalArgumentException("Unknown strand type: "</a>
<span class="sourceLineNo">251</span><a id="line.251">                                                + value);</a>
<span class="sourceLineNo">252</span><a id="line.252">                        }</a>
<span class="sourceLineNo">253</span><a id="line.253">                }</a>
<span class="sourceLineNo">254</span><a id="line.254"></a>
<span class="sourceLineNo">255</span><a id="line.255">                /**</a>
<span class="sourceLineNo">256</span><a id="line.256">                 * Returns the strand object that matches the symbol given. Throws an</a>
<span class="sourceLineNo">257</span><a id="line.257">                 * exception if it could not recognise the symbol. Symbol is usually</a>
<span class="sourceLineNo">258</span><a id="line.258">                 * +,-,?.</a>
<span class="sourceLineNo">259</span><a id="line.259">                 * </a>
<span class="sourceLineNo">260</span><a id="line.260">                 * @param name</a>
<span class="sourceLineNo">261</span><a id="line.261">                 *            the symbol of the strand.</a>
<span class="sourceLineNo">262</span><a id="line.262">                 * @return the strand matching that symbol.</a>
<span class="sourceLineNo">263</span><a id="line.263">                 */</a>
<span class="sourceLineNo">264</span><a id="line.264">                public static Strand forName(String name) {</a>
<span class="sourceLineNo">265</span><a id="line.265">                        if (name.equals("+"))</a>
<span class="sourceLineNo">266</span><a id="line.266">                                return POSITIVE_STRAND;</a>
<span class="sourceLineNo">267</span><a id="line.267">                        else if (name.equals("?"))</a>
<span class="sourceLineNo">268</span><a id="line.268">                                return UNKNOWN_STRAND;</a>
<span class="sourceLineNo">269</span><a id="line.269">                        else if (name.equals("."))</a>
<span class="sourceLineNo">270</span><a id="line.270">                                return UNKNOWN_STRAND;</a>
<span class="sourceLineNo">271</span><a id="line.271">                        else if (name.equals("-"))</a>
<span class="sourceLineNo">272</span><a id="line.272">                                return NEGATIVE_STRAND;</a>
<span class="sourceLineNo">273</span><a id="line.273">                        else</a>
<span class="sourceLineNo">274</span><a id="line.274">                                throw new IllegalArgumentException("Unknown strand type: "</a>
<span class="sourceLineNo">275</span><a id="line.275">                                                + name);</a>
<span class="sourceLineNo">276</span><a id="line.276">                }</a>
<span class="sourceLineNo">277</span><a id="line.277"></a>
<span class="sourceLineNo">278</span><a id="line.278">                // creates a strand with the given number and value</a>
<span class="sourceLineNo">279</span><a id="line.279">                private Strand(String name, int value) {</a>
<span class="sourceLineNo">280</span><a id="line.280">                        this.name = name;</a>
<span class="sourceLineNo">281</span><a id="line.281">                        this.value = value;</a>
<span class="sourceLineNo">282</span><a id="line.282">                }</a>
<span class="sourceLineNo">283</span><a id="line.283"></a>
<span class="sourceLineNo">284</span><a id="line.284">                /**</a>
<span class="sourceLineNo">285</span><a id="line.285">                 * Returns the numeric value of this strand.</a>
<span class="sourceLineNo">286</span><a id="line.286">                 * </a>
<span class="sourceLineNo">287</span><a id="line.287">                 * @return the numeric value.</a>
<span class="sourceLineNo">288</span><a id="line.288">                 */</a>
<span class="sourceLineNo">289</span><a id="line.289">                public int intValue() {</a>
<span class="sourceLineNo">290</span><a id="line.290">                        return this.value;</a>
<span class="sourceLineNo">291</span><a id="line.291">                }</a>
<span class="sourceLineNo">292</span><a id="line.292"></a>
<span class="sourceLineNo">293</span><a id="line.293">                /**</a>
<span class="sourceLineNo">294</span><a id="line.294">                 * Returns the string symbol of this strand.</a>
<span class="sourceLineNo">295</span><a id="line.295">                 * </a>
<span class="sourceLineNo">296</span><a id="line.296">                 * @return the string symbol.</a>
<span class="sourceLineNo">297</span><a id="line.297">                 */</a>
<span class="sourceLineNo">298</span><a id="line.298">                public String getName() {</a>
<span class="sourceLineNo">299</span><a id="line.299">                        return this.name;</a>
<span class="sourceLineNo">300</span><a id="line.300">                }</a>
<span class="sourceLineNo">301</span><a id="line.301"></a>
<span class="sourceLineNo">302</span><a id="line.302">                /**</a>
<span class="sourceLineNo">303</span><a id="line.303">                 * {@inheritDoc} Form: "symbol" (eg. +,-,?)</a>
<span class="sourceLineNo">304</span><a id="line.304">                 */</a>
<span class="sourceLineNo">305</span><a id="line.305">                public String toString() {</a>
<span class="sourceLineNo">306</span><a id="line.306">                        return this.name;</a>
<span class="sourceLineNo">307</span><a id="line.307">                }</a>
<span class="sourceLineNo">308</span><a id="line.308"></a>
<span class="sourceLineNo">309</span><a id="line.309">                /**</a>
<span class="sourceLineNo">310</span><a id="line.310">                 * {@inheritDoc}</a>
<span class="sourceLineNo">311</span><a id="line.311">                 */</a>
<span class="sourceLineNo">312</span><a id="line.312">                public int hashCode() {</a>
<span class="sourceLineNo">313</span><a id="line.313">                        int code = 17;</a>
<span class="sourceLineNo">314</span><a id="line.314">                        code = 31 * code + this.name.hashCode();</a>
<span class="sourceLineNo">315</span><a id="line.315">                        code = 31 * code + this.value;</a>
<span class="sourceLineNo">316</span><a id="line.316">                        return code;</a>
<span class="sourceLineNo">317</span><a id="line.317">                }</a>
<span class="sourceLineNo">318</span><a id="line.318"></a>
<span class="sourceLineNo">319</span><a id="line.319">                /**</a>
<span class="sourceLineNo">320</span><a id="line.320">                 * {@inheritDoc} Strands are equal if their numbers and symbols match.</a>
<span class="sourceLineNo">321</span><a id="line.321">                 */</a>
<span class="sourceLineNo">322</span><a id="line.322">                public boolean equals(Object o) {</a>
<span class="sourceLineNo">323</span><a id="line.323">                        if (!(o instanceof Strand))</a>
<span class="sourceLineNo">324</span><a id="line.324">                                return false;</a>
<span class="sourceLineNo">325</span><a id="line.325">                        if (o == this)</a>
<span class="sourceLineNo">326</span><a id="line.326">                                return true;</a>
<span class="sourceLineNo">327</span><a id="line.327">                        Strand them = (Strand) o;</a>
<span class="sourceLineNo">328</span><a id="line.328">                        if (!them.toString().equals(this.name))</a>
<span class="sourceLineNo">329</span><a id="line.329">                                return false;</a>
<span class="sourceLineNo">330</span><a id="line.330">                        if (them.intValue() != this.value)</a>
<span class="sourceLineNo">331</span><a id="line.331">                                return false;</a>
<span class="sourceLineNo">332</span><a id="line.332">                        return true;</a>
<span class="sourceLineNo">333</span><a id="line.333">                }</a>
<span class="sourceLineNo">334</span><a id="line.334"></a>
<span class="sourceLineNo">335</span><a id="line.335">                /**</a>
<span class="sourceLineNo">336</span><a id="line.336">                 * {@inheritDoc} Strands are compared first by symbol, then by number.</a>
<span class="sourceLineNo">337</span><a id="line.337">                 */</a>
<span class="sourceLineNo">338</span><a id="line.338">                public int compareTo(Object o) {</a>
<span class="sourceLineNo">339</span><a id="line.339">                        Strand fo = (Strand) o;</a>
<span class="sourceLineNo">340</span><a id="line.340">                        if (!this.name.equals(fo.toString()))</a>
<span class="sourceLineNo">341</span><a id="line.341">                                return this.name.compareTo(fo.toString());</a>
<span class="sourceLineNo">342</span><a id="line.342">                        return this.value - fo.intValue();</a>
<span class="sourceLineNo">343</span><a id="line.343">                }</a>
<span class="sourceLineNo">344</span><a id="line.344">        }</a>
<span class="sourceLineNo">345</span><a id="line.345"></a>
<span class="sourceLineNo">346</span><a id="line.346">        /**</a>
<span class="sourceLineNo">347</span><a id="line.347">         * Some useful tools for working with Locations.</a>
<span class="sourceLineNo">348</span><a id="line.348">         */</a>
<span class="sourceLineNo">349</span><a id="line.349">        public static class Tools {</a>
<span class="sourceLineNo">350</span><a id="line.350"></a>
<span class="sourceLineNo">351</span><a id="line.351">                // because we are static, we don't want to get instantiated</a>
<span class="sourceLineNo">352</span><a id="line.352">                private Tools() {</a>
<span class="sourceLineNo">353</span><a id="line.353">                }</a>
<span class="sourceLineNo">354</span><a id="line.354"></a>
<span class="sourceLineNo">355</span><a id="line.355">                /**</a>
<span class="sourceLineNo">356</span><a id="line.356">                 * Constructs a RichLocation object based on the given collection of</a>
<span class="sourceLineNo">357</span><a id="line.357">                 * members. It the collection contains a single location, that is</a>
<span class="sourceLineNo">358</span><a id="line.358">                 * returned. If it contains multiple locations it returns a</a>
<span class="sourceLineNo">359</span><a id="line.359">                 * CompoundRichLocation covering them all, with the default term</a>
<span class="sourceLineNo">360</span><a id="line.360">                 * associated. It returns the empty location if the collection was</a>
<span class="sourceLineNo">361</span><a id="line.361">                 * empty.</a>
<span class="sourceLineNo">362</span><a id="line.362">                 * </a>
<span class="sourceLineNo">363</span><a id="line.363">                 * @param members</a>
<span class="sourceLineNo">364</span><a id="line.364">                 *            the members to construct a location from.</a>
<span class="sourceLineNo">365</span><a id="line.365">                 * @return the corresponding RichLocation</a>
<span class="sourceLineNo">366</span><a id="line.366">                 */</a>
<span class="sourceLineNo">367</span><a id="line.367">                public static RichLocation construct(Collection&lt;Location&gt; members) {</a>
<span class="sourceLineNo">368</span><a id="line.368">                        if (members.size() == 0)</a>
<span class="sourceLineNo">369</span><a id="line.369">                                return RichLocation.EMPTY_LOCATION;</a>
<span class="sourceLineNo">370</span><a id="line.370">                        else if (members.size() == 1){</a>
<span class="sourceLineNo">371</span><a id="line.371">                            Location loc =  members.toArray(new Location[0])[0];</a>
<span class="sourceLineNo">372</span><a id="line.372">                            return RichLocation.Tools.enrich(loc);</a>
<span class="sourceLineNo">373</span><a id="line.373">                        } else if (isMultiSource(members))</a>
<span class="sourceLineNo">374</span><a id="line.374">                                return new MultiSourceCompoundRichLocation(members);</a>
<span class="sourceLineNo">375</span><a id="line.375">                        else</a>
<span class="sourceLineNo">376</span><a id="line.376">                                return new CompoundRichLocation(members);</a>
<span class="sourceLineNo">377</span><a id="line.377">                }</a>
<span class="sourceLineNo">378</span><a id="line.378"></a>
<span class="sourceLineNo">379</span><a id="line.379">                /**</a>
<span class="sourceLineNo">380</span><a id="line.380">                 * Returns false if all the locations in the set are from the same</a>
<span class="sourceLineNo">381</span><a id="line.381">                 * strand of the same sequence.</a>
<span class="sourceLineNo">382</span><a id="line.382">                 * </a>
<span class="sourceLineNo">383</span><a id="line.383">                 * @param members</a>
<span class="sourceLineNo">384</span><a id="line.384">                 *            the set of locations to check.</a>
<span class="sourceLineNo">385</span><a id="line.385">                 * @return true if they are from multiple sources.</a>
<span class="sourceLineNo">386</span><a id="line.386">                 */</a>
<span class="sourceLineNo">387</span><a id="line.387">                public static boolean isMultiSource(Collection&lt;Location&gt; members) {</a>
<span class="sourceLineNo">388</span><a id="line.388">                        RichLocation previous = null;</a>
<span class="sourceLineNo">389</span><a id="line.389">                        for (Iterator&lt;Location&gt; i = members.iterator(); i.hasNext();) {</a>
<span class="sourceLineNo">390</span><a id="line.390">                                RichLocation rl = enrich(i.next());</a>
<span class="sourceLineNo">391</span><a id="line.391">                                if (previous == null)</a>
<span class="sourceLineNo">392</span><a id="line.392">                                        previous = rl;</a>
<span class="sourceLineNo">393</span><a id="line.393">                                else {</a>
<span class="sourceLineNo">394</span><a id="line.394">                                        if (previous.getCircularLength() != rl.getCircularLength())</a>
<span class="sourceLineNo">395</span><a id="line.395">                                                return true;</a>
<span class="sourceLineNo">396</span><a id="line.396">                                        if ((previous.getCrossRef() == null &amp;&amp; rl.getCrossRef() != null)</a>
<span class="sourceLineNo">397</span><a id="line.397">                                                        || (previous.getCrossRef() != null &amp;&amp; rl</a>
<span class="sourceLineNo">398</span><a id="line.398">                                                                        .getCrossRef() == null)</a>
<span class="sourceLineNo">399</span><a id="line.399">                                                        || (previous.getCrossRef() != rl.getCrossRef() &amp;&amp; !previous</a>
<span class="sourceLineNo">400</span><a id="line.400">                                                                        .getCrossRef().equals(rl.getCrossRef())))</a>
<span class="sourceLineNo">401</span><a id="line.401">                                                return true;</a>
<span class="sourceLineNo">402</span><a id="line.402">                                        if ((previous.getStrand() == null &amp;&amp; rl.getStrand() != null)</a>
<span class="sourceLineNo">403</span><a id="line.403">                                                        || (previous.getStrand() != null &amp;&amp; rl.getStrand() == null)</a>
<span class="sourceLineNo">404</span><a id="line.404">                                                        || (previous.getStrand() != rl.getStrand() &amp;&amp; !previous</a>
<span class="sourceLineNo">405</span><a id="line.405">                                                                        .getStrand().equals(rl.getStrand())))</a>
<span class="sourceLineNo">406</span><a id="line.406">                                                return true;</a>
<span class="sourceLineNo">407</span><a id="line.407">                                }</a>
<span class="sourceLineNo">408</span><a id="line.408">                        }</a>
<span class="sourceLineNo">409</span><a id="line.409">                        return false;</a>
<span class="sourceLineNo">410</span><a id="line.410">                }</a>
<span class="sourceLineNo">411</span><a id="line.411"></a>
<span class="sourceLineNo">412</span><a id="line.412">                /**</a>
<span class="sourceLineNo">413</span><a id="line.413">                 * Takes a set of locations and tries to merge all pairs where the union</a>
<span class="sourceLineNo">414</span><a id="line.414">                 * operation results in a simple rich location, not a compound one.</a>
<span class="sourceLineNo">415</span><a id="line.415">                 * </a>
<span class="sourceLineNo">416</span><a id="line.416">                 * @param members</a>
<span class="sourceLineNo">417</span><a id="line.417">                 *            the members to merge</a>
<span class="sourceLineNo">418</span><a id="line.418">                 * @return the resulting merged set, which may have only one location in</a>
<span class="sourceLineNo">419</span><a id="line.419">                 *         it.</a>
<span class="sourceLineNo">420</span><a id="line.420">                 */</a>
<span class="sourceLineNo">421</span><a id="line.421">                public static Collection&lt;Location&gt; merge(Collection&lt;Location&gt; members) {</a>
<span class="sourceLineNo">422</span><a id="line.422">                        // flatten them out first so we don't end up recursing</a>
<span class="sourceLineNo">423</span><a id="line.423">                        List&lt;Location&gt; membersList = new ArrayList&lt;Location&gt;(</a>
<span class="sourceLineNo">424</span><a id="line.424">                                        flatten(members));</a>
<span class="sourceLineNo">425</span><a id="line.425">                        // all members are now singles so we can use single vs single union</a>
<span class="sourceLineNo">426</span><a id="line.426">                        // operations</a>
<span class="sourceLineNo">427</span><a id="line.427">                        if (membersList.size() &gt; 1) {</a>
<span class="sourceLineNo">428</span><a id="line.428">                                for (int p = 0; p &lt; (membersList.size() - 1); p++) {</a>
<span class="sourceLineNo">429</span><a id="line.429">                                        Location parent = membersList.get(p);</a>
<span class="sourceLineNo">430</span><a id="line.430">                                        for (int c = p + 1; c &lt; membersList.size(); c++) {</a>
<span class="sourceLineNo">431</span><a id="line.431">                                                Location child = membersList.get(c);</a>
<span class="sourceLineNo">432</span><a id="line.432">                                                Location union = parent.union(child);</a>
<span class="sourceLineNo">433</span><a id="line.433">                                                // if parent can merge with child</a>
<span class="sourceLineNo">434</span><a id="line.434">                                                if (union.isContiguous()) {</a>
<span class="sourceLineNo">435</span><a id="line.435">                                                        // replace parent with union</a>
<span class="sourceLineNo">436</span><a id="line.436">                                                        membersList.set(p, union);</a>
<span class="sourceLineNo">437</span><a id="line.437">                                                        // remove child</a>
<span class="sourceLineNo">438</span><a id="line.438">                                                        membersList.remove(c);</a>
<span class="sourceLineNo">439</span><a id="line.439">                                                        // check all children again</a>
<span class="sourceLineNo">440</span><a id="line.440">                                                        p--;</a>
<span class="sourceLineNo">441</span><a id="line.441">                                                        break;</a>
<span class="sourceLineNo">442</span><a id="line.442">                                                }</a>
<span class="sourceLineNo">443</span><a id="line.443">                                        }</a>
<span class="sourceLineNo">444</span><a id="line.444">                                }</a>
<span class="sourceLineNo">445</span><a id="line.445">                        }</a>
<span class="sourceLineNo">446</span><a id="line.446">                        return membersList;</a>
<span class="sourceLineNo">447</span><a id="line.447">                }</a>
<span class="sourceLineNo">448</span><a id="line.448"></a>
<span class="sourceLineNo">449</span><a id="line.449">                /**</a>
<span class="sourceLineNo">450</span><a id="line.450">                 * Takes a location and returns the set of all members. If any members</a>
<span class="sourceLineNo">451</span><a id="line.451">                 * are compound, it flattens them too.</a>
<span class="sourceLineNo">452</span><a id="line.452">                 * </a>
<span class="sourceLineNo">453</span><a id="line.453">                 * @param location</a>
<span class="sourceLineNo">454</span><a id="line.454">                 *            the location to flatten</a>
<span class="sourceLineNo">455</span><a id="line.455">                 * @return the flattened collection of members.</a>
<span class="sourceLineNo">456</span><a id="line.456">                 */</a>
<span class="sourceLineNo">457</span><a id="line.457">                public static Collection&lt;Location&gt; flatten(RichLocation location) {</a>
<span class="sourceLineNo">458</span><a id="line.458">                        List&lt;Location&gt; members = new ArrayList&lt;Location&gt;();</a>
<span class="sourceLineNo">459</span><a id="line.459">                        for (Iterator&lt;Location&gt; i = location.blockIterator(); i.hasNext();)</a>
<span class="sourceLineNo">460</span><a id="line.460">                                members.add(i.next());</a>
<span class="sourceLineNo">461</span><a id="line.461">                        return flatten(members);</a>
<span class="sourceLineNo">462</span><a id="line.462">                }</a>
<span class="sourceLineNo">463</span><a id="line.463"></a>
<span class="sourceLineNo">464</span><a id="line.464">                /**</a>
<span class="sourceLineNo">465</span><a id="line.465">                 * Takes a set of locations and returns the set of all members. If any</a>
<span class="sourceLineNo">466</span><a id="line.466">                 * members are compound, it flattens them too.</a>
<span class="sourceLineNo">467</span><a id="line.467">                 * </a>
<span class="sourceLineNo">468</span><a id="line.468">                 * @param members</a>
<span class="sourceLineNo">469</span><a id="line.469">                 *            the locations to flatten</a>
<span class="sourceLineNo">470</span><a id="line.470">                 * @return the flattened collection of members.</a>
<span class="sourceLineNo">471</span><a id="line.471">                 */</a>
<span class="sourceLineNo">472</span><a id="line.472">                public static Collection&lt;Location&gt; flatten(Collection&lt;Location&gt; members) {</a>
<span class="sourceLineNo">473</span><a id="line.473">                        List&lt;Location&gt; flattened = new ArrayList&lt;Location&gt;(members);</a>
<span class="sourceLineNo">474</span><a id="line.474">                        for (int i = 0; i &lt; flattened.size(); i++) {</a>
<span class="sourceLineNo">475</span><a id="line.475">                                Location member = flattened.get(i);</a>
<span class="sourceLineNo">476</span><a id="line.476">                                if (!member.isContiguous()) {</a>
<span class="sourceLineNo">477</span><a id="line.477">                                        flattened.remove(i);</a>
<span class="sourceLineNo">478</span><a id="line.478">                                        int insertPos = i;</a>
<span class="sourceLineNo">479</span><a id="line.479">                                        for (Iterator&lt;Location&gt; j = member.blockIterator(); j</a>
<span class="sourceLineNo">480</span><a id="line.480">                                                        .hasNext();)</a>
<span class="sourceLineNo">481</span><a id="line.481">                                                flattened.add(insertPos++, j.next());</a>
<span class="sourceLineNo">482</span><a id="line.482">                                        i--;</a>
<span class="sourceLineNo">483</span><a id="line.483">                                }</a>
<span class="sourceLineNo">484</span><a id="line.484">                        }</a>
<span class="sourceLineNo">485</span><a id="line.485">                        return flattened;</a>
<span class="sourceLineNo">486</span><a id="line.486">                }</a>
<span class="sourceLineNo">487</span><a id="line.487"></a>
<span class="sourceLineNo">488</span><a id="line.488">                /**</a>
<span class="sourceLineNo">489</span><a id="line.489">                 * Takes a start and end position on a circular location of given</a>
<span class="sourceLineNo">490</span><a id="line.490">                 * length, and shifts them left along the sequence until they sit at the</a>
<span class="sourceLineNo">491</span><a id="line.491">                 * earliest possible point where they still would represent the same</a>
<span class="sourceLineNo">492</span><a id="line.492">                 * sequence.</a>
<span class="sourceLineNo">493</span><a id="line.493">                 * </a>
<span class="sourceLineNo">494</span><a id="line.494">                 * @param start</a>
<span class="sourceLineNo">495</span><a id="line.495">                 *            the start of the circular location</a>
<span class="sourceLineNo">496</span><a id="line.496">                 * @param end</a>
<span class="sourceLineNo">497</span><a id="line.497">                 *            the end of the circular location</a>
<span class="sourceLineNo">498</span><a id="line.498">                 * @param seqLength</a>
<span class="sourceLineNo">499</span><a id="line.499">                 *            the circular length of the sequence underlying the</a>
<span class="sourceLineNo">500</span><a id="line.500">                 *            location</a>
<span class="sourceLineNo">501</span><a id="line.501">                 * @return an integer array where [0] is the translated start and [1]</a>
<span class="sourceLineNo">502</span><a id="line.502">                 *         the end.</a>
<span class="sourceLineNo">503</span><a id="line.503">                 */</a>
<span class="sourceLineNo">504</span><a id="line.504">                public static int[] modulateCircularLocation(int start, int end,</a>
<span class="sourceLineNo">505</span><a id="line.505">                                int seqLength) {</a>
<span class="sourceLineNo">506</span><a id="line.506">                        // Dummy case for non-circular sequences.</a>
<span class="sourceLineNo">507</span><a id="line.507">                        if (seqLength == 0)</a>
<span class="sourceLineNo">508</span><a id="line.508">                                return new int[] { start, end };</a>
<span class="sourceLineNo">509</span><a id="line.509">                        // Move the end to after the start.</a>
<span class="sourceLineNo">510</span><a id="line.510">                        while (end &lt; start)</a>
<span class="sourceLineNo">511</span><a id="line.511">                                end += seqLength;</a>
<span class="sourceLineNo">512</span><a id="line.512">                        // Calculate the length.</a>
<span class="sourceLineNo">513</span><a id="line.513">                        int locationLength = end - start;</a>
<span class="sourceLineNo">514</span><a id="line.514">                        // Move the start back till it can go no further</a>
<span class="sourceLineNo">515</span><a id="line.515">                        while (start &gt; seqLength)</a>
<span class="sourceLineNo">516</span><a id="line.516">                                start -= seqLength;</a>
<span class="sourceLineNo">517</span><a id="line.517">                        // Move the end back.</a>
<span class="sourceLineNo">518</span><a id="line.518">                        end = start + locationLength;</a>
<span class="sourceLineNo">519</span><a id="line.519">                        // Return results.</a>
<span class="sourceLineNo">520</span><a id="line.520">                        return new int[] { start, end };</a>
<span class="sourceLineNo">521</span><a id="line.521">                }</a>
<span class="sourceLineNo">522</span><a id="line.522"></a>
<span class="sourceLineNo">523</span><a id="line.523">                /**</a>
<span class="sourceLineNo">524</span><a id="line.524">                 * Takes two circular locations of given length, and shifts them left</a>
<span class="sourceLineNo">525</span><a id="line.525">                 * along the sequence until they sit at the earliest possible point</a>
<span class="sourceLineNo">526</span><a id="line.526">                 * where they still would represent the same sequence. The end result</a>
<span class="sourceLineNo">527</span><a id="line.527">                 * ensures that simple overlap calculations will always work on the</a>
<span class="sourceLineNo">528</span><a id="line.528">                 * coordinates returned.</a>
<span class="sourceLineNo">529</span><a id="line.529">                 * </a>
<span class="sourceLineNo">530</span><a id="line.530">                 * @param a</a>
<span class="sourceLineNo">531</span><a id="line.531">                 *            the first location to shift</a>
<span class="sourceLineNo">532</span><a id="line.532">                 * @param b</a>
<span class="sourceLineNo">533</span><a id="line.533">                 *            the second location to shift</a>
<span class="sourceLineNo">534</span><a id="line.534">                 * @param seqLength</a>
<span class="sourceLineNo">535</span><a id="line.535">                 *            the circular length of the sequence underlying the</a>
<span class="sourceLineNo">536</span><a id="line.536">                 *            location</a>
<span class="sourceLineNo">537</span><a id="line.537">                 * @return an integer array where [0] is the translated start and [1]</a>
<span class="sourceLineNo">538</span><a id="line.538">                 *         the end of location a, and [2] and [3] are the translated</a>
<span class="sourceLineNo">539</span><a id="line.539">                 *         start and end of location b.</a>
<span class="sourceLineNo">540</span><a id="line.540">                 */</a>
<span class="sourceLineNo">541</span><a id="line.541">                public static int[] modulateCircularLocationPair(Location a,</a>
<span class="sourceLineNo">542</span><a id="line.542">                                Location b, int seqLength) {</a>
<span class="sourceLineNo">543</span><a id="line.543">                        // Dummy case for non-circular locations.</a>
<span class="sourceLineNo">544</span><a id="line.544">                        if (seqLength == 0)</a>
<span class="sourceLineNo">545</span><a id="line.545">                                return new int[] { a.getMin(), a.getMax(), b.getMin(),</a>
<span class="sourceLineNo">546</span><a id="line.546">                                                b.getMax() };</a>
<span class="sourceLineNo">547</span><a id="line.547">                        // Modulate our start/end to shortest possible equivalent region</a>
<span class="sourceLineNo">548</span><a id="line.548">                        int[] aParts = modulateCircularLocation(a.getMin(), a.getMax(),</a>
<span class="sourceLineNo">549</span><a id="line.549">                                        seqLength);</a>
<span class="sourceLineNo">550</span><a id="line.550">                        int aStart = aParts[0];</a>
<span class="sourceLineNo">551</span><a id="line.551">                        int aEnd = aParts[1];</a>
<span class="sourceLineNo">552</span><a id="line.552">                        // Modulate their start/end to shortest possible equivalent region</a>
<span class="sourceLineNo">553</span><a id="line.553">                        int[] bParts = modulateCircularLocation(b.getMin(), b.getMax(),</a>
<span class="sourceLineNo">554</span><a id="line.554">                                        seqLength);</a>
<span class="sourceLineNo">555</span><a id="line.555">                        int bStart = bParts[0];</a>
<span class="sourceLineNo">556</span><a id="line.556">                        int bEnd = bParts[1];</a>
<span class="sourceLineNo">557</span><a id="line.557">                        // If we wrap and the point we are checking for is before our start,</a>
<span class="sourceLineNo">558</span><a id="line.558">                        // increment it by circularLength length</a>
<span class="sourceLineNo">559</span><a id="line.559">                        if (aEnd &gt; seqLength &amp;&amp; bStart &lt; aStart) {</a>
<span class="sourceLineNo">560</span><a id="line.560">                                bStart += seqLength;</a>
<span class="sourceLineNo">561</span><a id="line.561">                                bEnd += seqLength;</a>
<span class="sourceLineNo">562</span><a id="line.562">                        }</a>
<span class="sourceLineNo">563</span><a id="line.563">                        return new int[] { aStart, aEnd, bStart, bEnd };</a>
<span class="sourceLineNo">564</span><a id="line.564">                }</a>
<span class="sourceLineNo">565</span><a id="line.565"></a>
<span class="sourceLineNo">566</span><a id="line.566">                /**</a>
<span class="sourceLineNo">567</span><a id="line.567">                 * Takes a point on a circular location and moves it left until it falls</a>
<span class="sourceLineNo">568</span><a id="line.568">                 * at the earliest possible point that represents the same base.</a>
<span class="sourceLineNo">569</span><a id="line.569">                 * </a>
<span class="sourceLineNo">570</span><a id="line.570">                 * @param index</a>
<span class="sourceLineNo">571</span><a id="line.571">                 *            the point on the location to shift</a>
<span class="sourceLineNo">572</span><a id="line.572">                 * @param seqLength</a>
<span class="sourceLineNo">573</span><a id="line.573">                 *            the size of the circular location</a>
<span class="sourceLineNo">574</span><a id="line.574">                 * @return the shifted point</a>
<span class="sourceLineNo">575</span><a id="line.575">                 */</a>
<span class="sourceLineNo">576</span><a id="line.576">                public static int modulateCircularIndex(int index, int seqLength) {</a>
<span class="sourceLineNo">577</span><a id="line.577">                        // Dummy case</a>
<span class="sourceLineNo">578</span><a id="line.578">                        if (seqLength == 0)</a>
<span class="sourceLineNo">579</span><a id="line.579">                                return index;</a>
<span class="sourceLineNo">580</span><a id="line.580">                        // Modulate</a>
<span class="sourceLineNo">581</span><a id="line.581">                        while (index &gt; seqLength)</a>
<span class="sourceLineNo">582</span><a id="line.582">                                index -= seqLength;</a>
<span class="sourceLineNo">583</span><a id="line.583">                        return index;</a>
<span class="sourceLineNo">584</span><a id="line.584">                }</a>
<span class="sourceLineNo">585</span><a id="line.585"></a>
<span class="sourceLineNo">586</span><a id="line.586">                /**</a>
<span class="sourceLineNo">587</span><a id="line.587">                 * Attempts to convert a plain Location into a RichLocation.</a>
<span class="sourceLineNo">588</span><a id="line.588">                 * </a>
<span class="sourceLineNo">589</span><a id="line.589">                 * @param l</a>
<span class="sourceLineNo">590</span><a id="line.590">                 *            the location to convert</a>
<span class="sourceLineNo">591</span><a id="line.591">                 * @return the converted location</a>
<span class="sourceLineNo">592</span><a id="line.592">                 */</a>
<span class="sourceLineNo">593</span><a id="line.593">                public static RichLocation enrich(Location l) {</a>
<span class="sourceLineNo">594</span><a id="line.594">                        // Dummy case where location is already enriched</a>
<span class="sourceLineNo">595</span><a id="line.595">                        if (l instanceof RichLocation) {</a>
<span class="sourceLineNo">596</span><a id="line.596">                                return (RichLocation) l;</a>
<span class="sourceLineNo">597</span><a id="line.597">                        }</a>
<span class="sourceLineNo">598</span><a id="line.598">                        // Compound case</a>
<span class="sourceLineNo">599</span><a id="line.599">                        else if (l instanceof MergeLocation || !l.isContiguous()) {</a>
<span class="sourceLineNo">600</span><a id="line.600">                                List&lt;Location&gt; members = new ArrayList&lt;Location&gt;();</a>
<span class="sourceLineNo">601</span><a id="line.601">                                for (Iterator&lt;Location&gt; i = l.blockIterator(); i.hasNext();) {</a>
<span class="sourceLineNo">602</span><a id="line.602">                                        Location member = i.next();</a>
<span class="sourceLineNo">603</span><a id="line.603">                                        members.add(enrich(member));</a>
<span class="sourceLineNo">604</span><a id="line.604">                                }</a>
<span class="sourceLineNo">605</span><a id="line.605">                                return RichLocation.Tools.construct(RichLocation.Tools</a>
<span class="sourceLineNo">606</span><a id="line.606">                                                .merge(members));</a>
<span class="sourceLineNo">607</span><a id="line.607">                        }</a>
<span class="sourceLineNo">608</span><a id="line.608">                        // Fuzzy single points</a>
<span class="sourceLineNo">609</span><a id="line.609">                        else if (l instanceof FuzzyPointLocation) {</a>
<span class="sourceLineNo">610</span><a id="line.610">                                FuzzyPointLocation f = (FuzzyPointLocation) l;</a>
<span class="sourceLineNo">611</span><a id="line.611">                                Position pos = new SimplePosition(f.hasBoundedMin(), f</a>
<span class="sourceLineNo">612</span><a id="line.612">                                                .hasBoundedMax(), f.getMin(), f.getMax(),</a>
<span class="sourceLineNo">613</span><a id="line.613">                                                Position.IN_RANGE);</a>
<span class="sourceLineNo">614</span><a id="line.614">                                return new SimpleRichLocation(pos, 0); // 0 for no rank</a>
<span class="sourceLineNo">615</span><a id="line.615">                        }</a>
<span class="sourceLineNo">616</span><a id="line.616">                        // Fuzzy ranges</a>
<span class="sourceLineNo">617</span><a id="line.617">                        else if (l instanceof FuzzyLocation) {</a>
<span class="sourceLineNo">618</span><a id="line.618">                                FuzzyLocation f = (FuzzyLocation) l;</a>
<span class="sourceLineNo">619</span><a id="line.619">                                Position start = new SimplePosition(f.hasBoundedMin(), false, f</a>
<span class="sourceLineNo">620</span><a id="line.620">                                                .getMin());</a>
<span class="sourceLineNo">621</span><a id="line.621">                                Position end = new SimplePosition(false, f.hasBoundedMax(), f</a>
<span class="sourceLineNo">622</span><a id="line.622">                                                .getMax());</a>
<span class="sourceLineNo">623</span><a id="line.623">                                return new SimpleRichLocation(start, end, 0); // 0 for no rank</a>
<span class="sourceLineNo">624</span><a id="line.624">                        }</a>
<span class="sourceLineNo">625</span><a id="line.625">                        // Normal ranges</a>
<span class="sourceLineNo">626</span><a id="line.626">                        else if (l instanceof RangeLocation) {</a>
<span class="sourceLineNo">627</span><a id="line.627">                                RangeLocation r = (RangeLocation) l;</a>
<span class="sourceLineNo">628</span><a id="line.628">                                Position start = new SimplePosition(false, false, r.getMin());</a>
<span class="sourceLineNo">629</span><a id="line.629">                                Position end = new SimplePosition(false, false, r.getMax());</a>
<span class="sourceLineNo">630</span><a id="line.630">                                return new SimpleRichLocation(start, end, 0); // 0 for no rank</a>
<span class="sourceLineNo">631</span><a id="line.631">                        }</a>
<span class="sourceLineNo">632</span><a id="line.632">                        // Normal points</a>
<span class="sourceLineNo">633</span><a id="line.633">                        else if (l instanceof PointLocation) {</a>
<span class="sourceLineNo">634</span><a id="line.634">                                PointLocation p = (PointLocation) l;</a>
<span class="sourceLineNo">635</span><a id="line.635">                                Position pos = new SimplePosition(false, false, p.getMin());</a>
<span class="sourceLineNo">636</span><a id="line.636">                                return new SimpleRichLocation(pos, 0); // 0 for no rank</a>
<span class="sourceLineNo">637</span><a id="line.637">                        }</a>
<span class="sourceLineNo">638</span><a id="line.638">                        // Empty locations</a>
<span class="sourceLineNo">639</span><a id="line.639">                        else if (l.toString().equals("{}")) {</a>
<span class="sourceLineNo">640</span><a id="line.640">                                return EMPTY_LOCATION;</a>
<span class="sourceLineNo">641</span><a id="line.641">                        }</a>
<span class="sourceLineNo">642</span><a id="line.642">                        // All other cases</a>
<span class="sourceLineNo">643</span><a id="line.643">                        else {</a>
<span class="sourceLineNo">644</span><a id="line.644">                                throw new IllegalArgumentException(</a>
<span class="sourceLineNo">645</span><a id="line.645">                                                "Unable to enrich locations of type " + l.getClass());</a>
<span class="sourceLineNo">646</span><a id="line.646">                        }</a>
<span class="sourceLineNo">647</span><a id="line.647">                }</a>
<span class="sourceLineNo">648</span><a id="line.648">        }</a>
<span class="sourceLineNo">649</span><a id="line.649">}</a>




























































</pre>
</div>
</main>
</body>
</html>
